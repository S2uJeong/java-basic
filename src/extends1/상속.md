# 상속
- ex1 패키지 - 상속 필요성 (공통부분을 발견)
- ex2 패키지 - 상속 관계 이용
- ex3 패키지 - 상속과 기능 추가 - 확장에 용이한 상속관계
- overriding 패키지 - 상속과 메서드 오버라이딩 
- access 패키지 - 상속과 접근제어자 
- super1 패키지 - super
- super2 패키지 - super - 생성자

## 메서드 오버라이딩 조건
- 메서드 이름 : 메서드 이름이 같아야 한다.
- 메서드 매개변수 : 매개변수 타입, 순서, 개수가 같아야 한다.
- 반환타입 : 같아야 한다. 단, 반환 타입이 하위 클래스 타입일 수 있다.
- 접근 제어자 : 오버라이딩 메서드의 접근 제어자는 상위 클래스이 메서드보다 더 제한적이어서는 안된다. 
- 예외 : 오버라이딩 메서드는 상위 클래스의 메서드보다 더 많은 체크예외를 throws로 선언할 수 없다. 
- static, final, private : 이 키워드가 붙은 메서드는 오버라이딩 불가
  - static : 클래스 레벨에서 작동하므로 인스턴스 레벨에서 사용하는 오버라이딩이 의미없음. 클래스 이름을 통해 직접 접근해야한다.
  - final : 메서드 재정의를 금지한다.
  - private : 해당 클래스에서만 접근 가능해서 하위 클래스에 보이지 않는다.
- 생성자 오버라이딩 : 생성자는 오버라이딩 할 수 없다.  

### @Override
- 오버라이딩한 메서드 위에 붙이는 애노테이션
    - 안 붙여도 오버라이드 되지만 아래와 같은 이유로 개발자들은 꼭 붙인다.
- 오버라이드가 정확하게 안되면 컴파일 오류를 낸다.

  
## 상속관계
- 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용하게 해준다.
- 부모는 자식을 알 수 없지만,  자식은 부모를 알고 있다 `extends ___`.
  - 화살표는 아는 방향으로 가는것 
  
### 다중상속
- 허용하지 않는다. extends 대상은 하나만 선택할 수 있다.
- 대신에 인터페이스의 다중 구현을 허용해서 이러한 문제를 타파한다. 


## 상속과 메모리 구조
- 자식 클래스의 인스턴스를 생성하게 되면, 부모 클래스도 함께 인스턴스를 생성한다. 
  - 이때 참조값은 (`x001`) 로 하나이지만 실제로 그 안에는 부모/자식 두 가지 클래스 정보가 함께 있다.!
  - ![상속과 메모리구조.png](%BB%F3%BC%D3%B0%FA%20%B8%DE%B8%F0%B8%AE%B1%B8%C1%B6.png)
- 만약 같은 이름의 메서드가 부모/자식클래스에 다 있다면, 호출하는 변수의 타입(클래스)를 기준으로 선택한다. 
  - 현재 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾아 실행한다. 


## 상속과 접근제어 (protected)

## Super
- 부모와 자식의 필드명이 같거나 메서드가 오버라이딩 되어 있으면, 자식에서 부모의 필드나 메서드를 호출할 수 없다. 
- 이때, super 키워드를 사용하면 부모를 참조할 수 있다. 

### super - 생성자 
- 예제 : super2 패키지 
- 상속 관계의 인스턴스를 생성하면 결국 메모리 내부에는 자식과 부모 클래스가 각각 다 만들어진다.
  - 따라서 각각의 생성자도 모두 호출되어야 한다.
- 메모리에 공간이 생성되는 순서는 최상위 부모 클래스의 인스턴스 부터이다.
- 부모 클래스에 생성자가 없어서 기본 생성자가 자동 생성된 경우 -> `super()` (부모생성자호출) 생략가능.
- 생성자가 정의되어 있어, 기본생성자가 생성되지 않는경우 ->  `super()` 생략 불가
  - 부모 생성자 형식에 맞게 super() 호출해주자.
![상속관계에서 인스턴스 생성자 호출 구조.png](%BB%F3%BC%D3%B0%FC%B0%E8%BF%A1%BC%AD%20%C0%CE%BD%BA%C5%CF%BD%BA%20%BB%FD%BC%BA%C0%DA%20%C8%A3%C3%E2%20%B1%B8%C1%B6.png)